<!DOCTYPE html>

<html>
<head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width">
  <meta name="description" content="Projects, Ideas, and Life">
  <meta name="author" content="Eamon Bracht">
  <title>Eamon Bracht - More</title>
  <link rel="stylesheet" href="/css/style.css">
  <link href="https://use.fontawesome.com/releases/v5.0.6/css/all.css" rel="stylesheet">
  <script type="text/javascript" src="http://latex.codecogs.com/latexit.js"></script>
  <script type="text/javascript">
  LatexIT.add('p',true);
  </script></head>
<body>
  <header>
    <div class="container">
      <div id="branding">
        <h1><i class="fa fa-map"></i> <span class="highlight">Eamon</span> Bracht</h1>
      </div>
      <nav>
        <ul>
          <li><a href="index.html">Home</a></li>
          <li><a href="about.html">About</a></li>
          <li class="current"><a href="more.html">Projects</a></li>
        </ul>
      </nav>
    </div>
  </header>
  <section id="projcase" style = "background-image:url('../img/montana.jpeg'")>
    <div class="container">

      <h1><i><span id = "highlighted">sorting algorithms</span></i></h1>
      <div>
      </section>
      <section id = "main">
        <div class= "container">
          <font class="page-title", size = "5">
            <i><span id = "notrans">merge sort</span></i>
          </font>
        </div>
        <hr>
        <div class="container">
          <article id="code-col">
            <figure style="margin:0px">
              <pre>
                <code>
void merge(int arr[], int l, int m, int r)
{
  int i, j, k;
  int n1 = m - l + 1;
  int n2 =  r - m;

  /* create temp arrays */
  int L[n1], R[n2];

  /* Copy data to temp arrays L[] and R[] */
  for (i = 0; i < n1; i++)
  L[i] = arr[l + i];
  for (j = 0; j < n2; j++)
  R[j] = arr[m + 1+ j];

  /* Merge the temp arrays back into arr[l..r]*/
  i = 0; // Initial index of first subarray
  j = 0; // Initial index of second subarray
  k = l; // Initial index of merged subarray
  while (i < n1 && j < n2)
  {
    if (L[i] <= R[j])
    {
      arr[k] = L[i];
      i++;
    }
    else
    {
      arr[k] = R[j];
      j++;
    }
    k++;
  }

  /* Copy the remaining elements of L[], if there
  are any */
  while (i < n1)
  {
    arr[k] = L[i];
    i++;
    k++;
  }

  /* Copy the remaining elements of R[], if there
  are any */
  while (j < n2)
  {
    arr[k] = R[j];
    j++;
    k++;
  }
}
                </code>
              </pre>
            </figure>
          </article>
          <aside id="graph-col">
            <figure style="margin:0px">
              <pre>
                <code style="font-size:10px">
void mergeSort(int arr[], int l, int r)
{
    if (l < r)
    {
        // Same as (l+r)/2, but avoids overflow for
        // large l and h
        int m = l+(r-l)/2;

        // Sort first and second halves
        mergeSort(arr, l, m);
        mergeSort(arr, m+1, r);

        merge(arr, l, m, r);
    }
}
                </code>
              </pre>
            </figure>
          </aside>
        </div>
        <hr>
<div class="container">
  <article class="main-col">
    <p>
      Merge sort is the fastest of the sorting algorithms running in $O(n\log n)$.</p>
    <img src = "img/mergesort.png" alt = "diagram of merge sort" class="center">
    <p>
      It is a recursive function meaning that it requires a helper function,
    in this case, <code>merge</code>, which recombines the arrays once they reach size
    $n = 1$.

    </p>
  </article>

</div>
    </section>
